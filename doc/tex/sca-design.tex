
Many embedded implementations include power side-channels in their threat
model.
Having identified ISE variant $3$ detailed in
\REFSEC{sec:design:v3} as a strong candidate for embedded $32$-bit
RISC-V cores, we now show a possible
way of extending the ISE further to add power side-channel resistance
with minimal area and performance overheads.
We aim for $1$'st order side-channel security.

As described in \cite{TilGro:07}, there are several broad approaches
to adding power side-channel security to ISEs which we summarise here:

1) The data path can be implemented in a secure logic style, which always
consumes energy at the same rate, regardless of the values being computed on.
This comes with a significant overhead in terms of silicon area and
gate-level performance.
It also requires that secret values only be stored in secure logic
elements.
This can be undermined when loading keys from memory, since they must
pass through any register stages in the memory hierarchy, which are
unlikely to be implemented in a secure logic style.

2) Random pre-charging involves sandwiching every instruction which
manipulates a secret value with instructions which operate on random values.
As the authors of \cite{TilGro:07} note, it provides only a modest
improvement in security, and comes with a $100\%$ performance overhead;
since every secret manipulating instruction must be accompanied by
a random-pre-charging partner.

3) The authors also describe a small ``secure zone'' within the processor,
implemented in a secure logic style and responsible for
mask storage, generation and all computations on secret data.
The aim is to keep the secure zone as small and separate from the main
processor data-path as possible.

\subsection{Design Overview}

We extend ISE variant $3$ to support 1'st order masking.
To this end, the secret key is represented as two boolean masked shares.
An implementation of the AES block encrypt/decrypt function requires
eight registers: four for the current round state, four to load the
next round key into and then accumulate the next round state.
Doubling this requirement to store shares of each secret variable
in the General Purpose Register (GPR) file is un-reasonable.
It would require drastic modifications to the instruction definitions and
register file to read four registers (two sources, of two shares each) and
write two registers.

Instead, we define a new, $8$-element ``Mask Register File'' (MRF).
Each mask register $M_i$ is $32$-bits wide, and stores the mask for
one of the GPRs.
We use a fixed mapping between GPRs and mask registers;
not all GPRs have a corresponding mask register.
({\bf TODO:} define this mapping. E.g. \{a0..a3,t0..t4\} onto MRF \{0..7\}).

Share $0$ of each secret value is loaded into the GPRs.
We define a new Load Mask instruction {\tt lm rd, imm(rs1)} which
loads {\em the mask for GPR {\tt rd}} from memory into the corresponding
MRF entry.
A corresponding Store Mask instruction {\tt sm rs2, imm(rs1)} writes
the mask corresponding to GPR {\tt rs2} to memory.
The {\tt sm} instruction is only used for context switches, and
destructivley reads the MRF register value to prevent it being
leaked to other applications running on the same core\footnote{
    In this case, destructive could mean set to zero (which could
    leak the hamming weight of the mask) or randomising it's value.}.
We require that the secret values be stored in shared form in memory
(rather than splitting them into shares upon being loaded)
to extend the SCA protection boundary outside the CPU.
Otherwise, the hamming weight of un-masked secret values would be
leaked by memory-hierarchy registers outside the CPU.

When an ISE instruction is executed such that any of its GPR source
registers also map onto an MRF register, both GPR and MRF are
read simultaneously and fed to the AES functional unit.
If any GPR source does not map to an MRF register, we assume that
operand is un-masked and represent the other share as $0$.

Within the AES FU the instruction result is computed entirely in it's
masked representation.
The result shares are then re-masked before being written back to the
GPRs and MRF.
This is nessesary, because the ISE variant $3$ instructions are designed
such that {\tt rs1=rd} for all use cases.
Without re-masking, overwriting a source with the result could cause 
$1$'st order leakage.

If the destination register is in the set which has a corresponding
mask register, share $0$ is stored in the GPRs, share $1$ in the MRF.
If destination is not a GPR, result is written back un-masked.
This means that in the final encrypt/decrypt round, we can obtain
the un-masked results without having to store the shares to memory,
load them back and un-mask them.

\subsection{Implementation}

We use the \CORE{2} core as the basis for our side-channel secure
implementation of ISE variant $3$.
\REFFIG{fig:sca:uarch} shows a block diagram of the modifications
made to the core, and which datapaths carry masked data.

\begin{figure}
\caption{Block diagram of the modifications to the \CORE{2} core,
supporting an extended version of ISE variant $3$ for side-channel
security. {\bf TODO}}
\label{fig:sca:uarch}
\end{figure}


\subsection{Evaluation}

Lorem ipsum doler set amet...

