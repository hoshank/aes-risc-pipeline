
\subsection{Evaluation Discussion}
\label{sec:eval:results}

\begin{table}[]
\centering
\begin{tabular}{l|rr|rr|rr|rr}
& \multicolumn{2}{c}{\begin{tabular}[c]{@{}c@{}}AES 128 Block\\ Encrypt\end{tabular}}
& \multicolumn{2}{c}{\begin{tabular}[c]{@{}c@{}}AES 128 Block\\ Decrypt\end{tabular}}
& \multicolumn{2}{c}{\begin{tabular}[c]{@{}c@{}}KeySchedule\\ Encrypt\end{tabular}} 
& \multicolumn{2}{c}{\begin{tabular}[c]{@{}c@{}}KeySchedule\\ Decrypt\end{tabular}}
\\
Variant      & iret  & cycles & iret  & cycles & iret & cycles & iret  & cycles   \\
\hline       
V1 (Latency) &  2.12 &  2.01  &  2.12 &  1.94  & 2.48 & 1.98   &  9.35 &  7.47    \\
V2 (Latency) &  4.69 &  3.65  &  4.67 &  3.58  & 2.43 & 1.87   &  5.73 &  3.90    \\
V5 (Latency) &  3.84 &  3.12  &  3.84 &  3.03  & 1.28 & 1.13   &  4.89 &  4.35    \\
V3           & {\bf 13.01} & {\bf 10.94}  & {\bf 13.01} & {\bf 10.89}  & {\bf 6.80} & {\bf 5.62}   &  9.00 &  7.07    \\
V4           & TODO  &        &       &        &      &        &       &          \\
V1 (Size)    &  3.39 &  2.57  &  3.39 &  2.46  & 3.96 & 2.82   & {\bf 14.94} &  {\bf 10.70}   \\
V2 (Size)    & 12.05 &  5.55  & 12.00 &  5.44  & 6.23 & 4.43   & 14.72 &  8.28    \\
V5 (Size)    &  8.22 &  3.86  &  8.22 &  3.83  & 2.74 & 2.29   & 10.46 &  8.79
\end{tabular}
\caption{Comparison of performance improvement unit-area for each
variant. Obtained by dividing the speedup in terms of instructions
executed relative to the baseline T-table implementation
(See \REFTAB{tab:eval:sw:perf:scarv}) by the
normalised size of the dedicated ISE logic, as shown in
\REFTAB{tab:eval:hw}.
We deliberately omit the size of the host core from our calculation,
as this dominates the total size of the system and detracts from
the comparison.
The \CORE{2} core results were used for these numbers, but the
same conclusions may be drawn from hte \CORE{1} results.
}
\label{tab:eval:results}
\end{table}

For the $32$-bit variants (V1,V2,V3,V5) our primary metric is
performance/area efficiency, since these ISEs must be sensible to
implement in small, embedded class cores.
To this, end we calculate an efficiency score by calculating the speedup
of each variant relative to the T-table basline, and dividing it
by the normalised size of each variant
(see ``ISE Size'' column of \REFTAB{tab:eval:hw}).
\REFTAB{tab:eval:results} shows the performance / area efficiency results.

Qualitativley, we place more weight on the block encrypt/decrypt results
than the KeySchedule results, as one typically performs many more
block operations than KeySchedules.
In almost all cases, we find that Variant $3$ is clearly much more
efficient in terms of performance per unit area.
The size optimised version of Variant $2$ performs almost on par with
Variant $3$ when looking at performance/area efficiency in terms of
instructions retired.
When looking at actual execution times in terms of cycles however,
it is slower than Variant $3$ in all cases.

Based on these results, we believe that for $32$-bit RISC-V cores,
ISE Variant $3$ makes the best candidate for standardisation,
based on its efficiency, raw performance and simplicity to implement.

For the $64$-bit case, we see that ({\bf TODO}...)
