% =============================================================================

\begin{table}[p]
\centering
\begin{tabular}{|l|c|c|rrrrrr|}
\hline
ISA    & Karatsuba & Reduce & \VERB{grev}
                            & \VERB{xor}
                            & \VERB{s[lr]li}
                            & \VERB{clmul} 
                            & \VERB{clmulh}
                            & Total \\
\hline
\hline
RV32IB &        no &    mul &$  4$&$ 36$&$  0$&$ 20$&$ 20$&$ 80$ \\
RV32IB &        no &  shift &$  4$&$ 56$&$ 24$&$ 16$&$ 16$&$116$ \\
RV32IB &       yes &    mul &$  4$&$ 52$&$  0$&$ 13$&$ 13$&$ 82$ \\
RV32IB &       yes &  shift &$  4$&$ 72$&$ 24$&$  9$&$  9$&$118$ \\
\hline
RV64IB &        no &    mul &$  2$&$ 10$&$  0$&$  6$&$  6$&$ 24$ \\
RV64IB &        no &  shift &$  2$&$ 20$&$ 12$&$  4$&$  4$&$ 42$ \\
RV64IB &       yes &    mul &$  2$&$ 14$&$  0$&$  5$&$  5$&$ 26$ \\
RV64IB &       yes &  shift &$  2$&$ 24$&$ 12$&$  3$&$  3$&$ 44$ \\
\hline
\end{tabular}
\caption{
  Instruction    counts for multiplication in $\F_{2^{128}}$ as used by \ALG{GHASH}.
}
\label{tab:gcm:instrs}
\end{table}

\begin{table}[p]
\centering
\begin{tabular}{|l|c|c|rrrr|}
\hline
ISA    & Karatsuba & Reduce & $1$-cycle       & $2$-cycle       & $3$-cycle       & $6$-cycle       \\
       &           &        & \VERB{clmul[h]} & \VERB{clmul[h]} & \VERB{clmul[h]} & \VERB{clmul[h]} \\
\hline
\hline
RV32IB &        no &    mul &$      {\bf  80}$&$           120 $&$           160 $&$           280 $\\
RV32IB &        no &  shift &$           116 $&$           148 $&$           180 $&$           276 $\\
RV32IB &       yes &    mul &$            82 $&$      {\bf 108}$&$      {\bf 134}$&$           212 $\\
RV32IB &       yes &  shift &$           118 $&$           136 $&$           154 $&$      {\bf 208}$\\
\hline
RV64IB &        no &    mul &$      {\bf  24}$&$      {\bf  36}$&$            48 $&$            84 $\\
RV64IB &        no &  shift &$            42 $&$            50 $&$            58 $&$            82 $\\
RV64IB &       yes &    mul &$            26 $&$      {\bf  36}$&$      {\bf  46}$&$            76 $\\
RV64IB &       yes &  shift &$            44 $&$            50 $&$            56 $&$      {\bf  74}$\\
\hline
\end{tabular}
\caption{
  Modelled cycle counts for multiplication in $\F_{2^{128}}$ as used by \ALG{GHASH}.
}
\label{tab:gcm:cycles}
\end{table}

% -----------------------------------------------------------------------------

Per
~\REFSEC{sec:bg:aes_usage},
The Galois/Counter Mode (GCM)
~\cite{NIST:sp.800.38d}
is a block cipher mode of operation which 
supports authenticated encryption.
AES-GCM refers to an instantiation using AES as the underlying block cipher, 
which is the only case mandated by TLS 1.3~\cite[Section 9.1]{rfc:8446}; the
importance of this construction means GCM and AES are frequently considered 
together from an implementation and evaluation perspective.

Again 
per
~\REFSEC{sec:bg:aes_usage},
the computational core of AES-GCM is formed from 
1) \ALG{GCTR}, i.e., AES encryption,
   and
2) \ALG{GHASH}.
Since we dealt with efficient implementation of AES and hence \ALG{GCTR} in
\REFSEC{sec:ise}, we turn our attention to \ALG{GHASH}.  Rather than further 
embelish the ISE for AES, we instead focus on use of the existing
standard 
B~\cite[Section 17]{RV:ISA:I:19}
extension.

% -----------------------------------------------------------------------------

\paragraph{An overview of           the B extension.}

% TODO: brief overview of BitManip

% -----------------------------------------------------------------------------

\paragraph{Implementing GHASH using the B extension.}

GHASH~\cite[Section 6.4]{NIST:sp.800.38d} is a universal hash defined over the binary field $\F_{2^{128}}$.

Converting the inputs to a little-endian representation is achieved
using the 
{\tt grev} (Generalised Reverse)
instruction to reverse all of the bits in each byte
of an input word.
On RV32, this requires four {\tt grev} instructions, while RV64 requires
only two.

Addition in the field is simply the {\tt xor} operation, i.e. addition
modulo $2$.
Multiplication is more complex, requiring ``carry-less multiply''
{\tt clmul[h]} instructions to implement efficiently.
The {\tt clmul} instruction computes the carry-less product of two source
registers and writes back the low half
(i.e. $32$-bits on RV32, $64$-bits on RV64)
of the result.
The {\tt clmulh} instruction does the same, but writes the {\em high}
half of the result.
Pairs of {\tt clmulh/clmul} instructions
should be scheduled adjacently, so that micro-architectures can employ
macro-op fusion to compute both results at once.

Computing the $256$-bit result of the $128*128$-bit multiplication
on RISC-V with the Bit-manipulation extension requires
four {\tt clmulh/clmul} pairs for RV64,
and $16$ pairs on RV32.
This may be sped up asymptotically using the Karatsuba method,
resulting in $3$ pairs on RV64 and $9$ pairs on RV32
at the cost of additional {\tt xor} operations.

Reducing the $256$-bit multiplication result back to $128$-bits
can generally be done in one of two ways:
1) A shift reduction, made possible by the low hamming weight of
the primitive polynomial
or
2) a multiplication reduction; analogous to the Montgomery or
Barret methods.
The fastest method depends on the relative speed of
the carry-less multiply instructions compared to the basic
shift and {\tt xor} instructions.

\REFTAB{tab:gcm:instrs} shows instruction counts for the GHASH multiplication
operation implemented using the different combinations of base architecture,
multiplication and reduction methods.
\REFTAB{tab:gcm:cycles} then estimates the execution time in cycles
for a scalar CPU assuming that {\tt grev}, {\tt xor}, and shifts take a
single cycle.
We can see that if the {\tt clmul} instructions take twice the time
of a shift/{\tt xor}, then the Karatsuba method is worthwhile.
If the {\tt clmul} instructions are six or more times slower than
a shift/{\tt xor}, then it is worthwhile to implement a shift/{\tt xor}
based reduction.
These tables inform developers as to the {\em fastest} way to implement
the GHASH multiplication in a scalar CPU.
This may not be the only concern, for example embedded applications may
prefer the smaller code size or lower instruction counts (and hence
lower energy consumption) over raw performance.

We also note that in order to be usable for cryptographic purposes, the
{\tt clmul} implementation {\em must} be constant time with respect
to its inputs.
An early-out implementaiton will result in a timing channel (cf.~\cite{GOPT:09}).

% =============================================================================
