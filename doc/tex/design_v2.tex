% =============================================================================

\begin{figure}
\begin{lstlisting}[language=pseudo,style=block]
saes.v2.encs rd, rs1, rs2 : v2.SubBytes(rd, rs1, rs2, fwd=1)
saes.v2.decs rd, rs1, rs2 : v2.SubBytes(rd, rs1, rs2, fwd=0)
saes.v2.encm rd, rs1, rs2 : v2.MixColumns(rd, rs1, rs2, fwd=1)
saes.v2.decm rd, rs1, rs2 : v2.MixColumns(rd, rs1, rs2, fwd=0)
\end{lstlisting}
\caption{
    Instruction mnemonics for variant 2.
    See \REFSEC{sec:pseudo}, \REFFIG{fig:pseudo:v2} for detailed
    descriptions of the pseudo-code functions.
}
\label{fig:mnemonics:v2}
\end{figure}

\REFFIG{fig:mnemonics:v2} shows the mnemonics and pseudo-code functions
for variant 2.
Here we reproduce the instructions proposed in Section $4.3$ of
\cite{TilGro:06}.
We continue to store the AES column-wise in $4$ $32$-bit words.
By using two source registers however,
the ShiftRows transformation can be implicitly performed by selecting
appropriate bytes from each source word.
\REFFIG{fig:design:fu_block:v2}
shows this.
Executing $4$  {\tt v2.encs}/{\tt v2.encm} instructions each hence
performs the entire SubBytes, ShiftRows and MixColumns steps.
The {\tt v2.encs} instruction can be used for the KeySchedule by
making {\tt rs1} equal to {\tt rs2}.

A single encryption round using this variant requires $16$ instructions
in total:
$4$ {\tt saes.v2.sub.enc} instructions to perform SubBytes and part of
shift rows,
$4$ {\tt saes.v2.mix.enc} instructions to perform MixColumns and the
remainder of shift rows,
$4$ load-word instructions to fetch the round key
and
$4$ {\tt xor} instructions to add the round key.

Because the final round does not include MixColumns, we must
complete the final ShiftRows operation with an additional
$12$ {\tt and}/{\tt or} instructions.

% =============================================================================
