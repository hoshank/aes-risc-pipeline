% =============================================================================

\begin{figure}
\begin{lstlisting}[language=pseudo,style=block]
saes.v2.encs rd, rs1, rs2 : v2.SubBytes(rd, rs1, rs2, fwd=1)
saes.v2.decs rd, rs1, rs2 : v2.SubBytes(rd, rs1, rs2, fwd=0)
saes.v2.encm rd, rs1, rs2 : v2.MixColumns(rd, rs1, rs2, fwd=1)
saes.v2.decm rd, rs1, rs2 : v2.MixColumns(rd, rs1, rs2, fwd=0)
\end{lstlisting}
\caption{
    Instruction mnemonics for variant 2.
    See \REFSEC{sec:pseudo}, \REFFIG{fig:pseudo:v2} for detailed
    descriptions of the pseudo-code functions.
}
\label{fig:mnemonics:v2}
\end{figure}

\REFFIG{fig:mnemonics:v2} shows the mnemonics and pseudo-code functions
for variant 2.
Here we reproduce the instructions proposed in Section $4.3$ of
\cite{TilGro:06}.
We continute to store the AES column-wise in $4$ $32$-bit words.
By using two source registers however,
the ShiftRows transformation can be implicitly performed by selecting
appropriate bytes from each source word.
\REFFIG{fig:design:fu_block:v2}
shows this.
Executing $4$  {\tt v2.encs}/{\tt v2.encm} instructions each hence
performs the entire SubBytes, ShiftRows and MixColumns steps.
The {\tt v2.encs} instruction can be used for the KeySchedule by
making {\tt rs1} equal to {\tt rs2}.

% =============================================================================
