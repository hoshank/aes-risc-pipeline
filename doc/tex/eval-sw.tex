
\subsection{Software Evaluation}
\label{sec:eval:sw}

To evaluate the software performance, we implemented AES 128, and
measure the static code size, instruction execution counts and cycle
counts of the Key Schedule, Encrypt and Decrypt functions.
We also separate generation of the KeySchedule for Encrypt and Decrypt.
A T-table implementation of AES (See \REFSEC{sec:bg:aes_impl_sw})
is used as a performance baseline.

\REFTAB{tab:eval:sw:size} shows the static code size for each
function.
For the Encrypt and Decrypt functions, all versions are very similar
in terms of code size.
The 32-bit variants (V1,V2,V3,V5) all use loop-based implementations.
V1, V2, V5 implement one round per loop iteration. V3 implements two
rounds per loop iteration to avoid needless register move operations.
The 64-bit variant (V4) uses a completely un-rolled implementation.

\REFTAB{tab:eval:sw:perf:scarv}
and
\REFTAB{tab:eval:sw:perf:rocket}
give cycle and instruction counts for each
variant under the \CORE{2} and \CORE{1} cores respectively.
Each implementation uses word-aligned state, meaning the input blocks
can be loaded with $4$ load-word instructions on $32$-bit host cores,
or $2$ load-double instructions on the $64$-bit host cores.
For the Encrypt/Decrypt columns, we show instruction execution counts
and processor clock cycle measurements for a single block
encryption of AES-128.
Likewise, the KeySchedule columns are for a single AES-128 KeySchedule
operation.

% ------------------------------------------------------------

We can see from the tables that ({\bf TODO}).

% ------------------------------------------------------------

{\bf TODO:} Table of per round instruction counts, split by
compute / load / store / loop management?

% ------------------------------------------------------------

%
% Static Code Size Results
%

\begin{table}
\centering
\begin{tabular}{l|c|c|c|c|c}
Variant &
KeySchedule Enc  &
KeySchedule Dec  &
Encrypt Block    &
Decrypt Block    &
.data   \\ \hline
%Byte   & 312     &  -        &       &       & 522   \\
T-table & 154     & $174\star$& 804   & 804   & 5120  \\
V1      & 68      &  -        & 424   & 424   & 10    \\
V2      & 68      & $62\star$ & 234   & 238   & 10    \\
V3      & 86      & $64\star$ & 290   & 290   & 10    \\
V4      & 168     & $100\star$& 268   & 268   &  0    \\
V5      &$82+208 $&  -        & 266   & 278   & 10    \\
\end{tabular}
\caption{
Static code size metrics for each variant, measured in bytes.
These are measured targeting the {\tt rv32imc} base ISA for all variants,
except for V4, which targets {\tt rv64imc}.
Decryption KeySchedule entries with a $\star$ indicate that the
implementation uses the Equivalent Inverse Cipher construction
\cite[Section 5.3.5, Page 23]{FIPS:197}, meaning that the
Decrypt KeySchedule calls the Encrypt KeySchedule, then performs some
additional post processing. The code size listed is for the post processing.
The V5 Encrypt Key Schedule is split into the basic KeySchedule
operation, plus a re-arrangment of the bytes in each word to make
KeyAddition more efficient in subsequent encrypt/decrypt operations.
}
\label{tab:eval:sw:size}
\end{table}

%
% SCARV CPU Performance Results
%

\begin{table}
\centering
\begin{tabular}{l|cc|cc|cc|cc}
& \multicolumn{2}{c}{\begin{tabular}[c]{@{}c@{}}AES 128 Block\\ Encrypt\end{tabular}}
& \multicolumn{2}{c}{\begin{tabular}[c]{@{}c@{}}AES 128 Block\\ Decrypt\end{tabular}}
& \multicolumn{2}{c}{\begin{tabular}[c]{@{}c@{}}KeySchedule\\ Encrypt\end{tabular}} 
& \multicolumn{2}{c}{\begin{tabular}[c]{@{}c@{}}KeySchedule\\ Decrypt\end{tabular}}
\\
Variant     &  iret & cycles & iret & cycles & iret & cycles & iret & cycles \\ \hline
%Byte       & 4228 & 7061 & 7652 & 11587& 926 & 3887 & 926 & 3886   \\
 T-table     & 953  & 1078 & 953  & 1058 & 445 & 555 & 1726 & 2202    \\
V1 (Latency)& 533  & 635  & 533  & 647  & 213 & 333 & 219  & 350     \\
V2 (Latency)& 236  & 343  & 237  & 343  & 213 & 344 & 350  & 656     \\
V5 (Latency)& 248  & 346  & 248  & 349  & 347 & 489 & 353  & 506     \\
V1 (Size)   & 533  & 795  & 533  & 815  & 213 & 373 & 219  & 390     \\
V2 (Size)   & 236  & 580  & 237  & 580  & 213 & 374 & 350  & 794     \\
V3          & 261  & 351  & 261  & 346  & 233 & 352 & 683  & 1109    \\
V5 (Size)   & 248  & 598  & 248  & 590  & 347 & 519 & 353  & 536  
\end{tabular}
\caption{
Performance results for the \CORE{2} core.
Note the absence of variant 4, as it is designed for 64-bit targets only.
}
\label{tab:eval:sw:perf:scarv}
\end{table}

%
% Rocket Core Performance Results
%

\begin{table}
\centering
\begin{tabular}{l|cc|cc|cc|cc}
& \multicolumn{2}{c}{\begin{tabular}[c]{@{}c@{}}AES 128 Block\\ Encrypt\end{tabular}}
& \multicolumn{2}{c}{\begin{tabular}[c]{@{}c@{}}AES 128 Block\\ Decrypt\end{tabular}}
& \multicolumn{2}{c}{\begin{tabular}[c]{@{}c@{}}KeySchedule\\ Encrypt\end{tabular}} 
& \multicolumn{2}{c}{\begin{tabular}[c]{@{}c@{}}KeySchedule\\ Decrypt\end{tabular}}
\\
Variant     &  iret & cycles & iret & cycles & iret & cycles & iret & cycles\\
\hline
%Byte       &       &        &      &        &      &        &      &      \\
T-table     & 948   &  1143  & 949  &  1025  & 444  & 478    & 1726 & 1977 \\
V1 (Latency)& 528   &  685   & 529  &  680   & 212  & 341    & 214  & 290  \\
V2 (Latency)& 231   &  359   & 233  &  368   & 212  & 315    & 350  & 508  \\
V5 (Latency)& 243   &  414   & 244  &  319   & 346  & 427    & 348  & 424  \\
V1 (Size)   & 528   &  804   & 529  &  744   & 212  & 357    & 214  & 335  \\
V2 (Size)   & 231   &  511   & 233  &  520   & 212  & 345    & 350  & 646  \\
V3          & 253   &  445   & 254  &  445   & 233  & 470    & 674  & 2425 \\
V4          & TODO  &        &      &        &      &        &      &      \\
V5 (Size)   & 243   &  585   & 244  &  543   & 346  & 504    & 348  & 454  \\
\end{tabular}
\caption{
Performance results for the \CORE{1} core.
}
\label{tab:eval:sw:perf:rocket}
\end{table}

% =============================================================================
