
Many embedded implementations include power side-channels in their threat
model.
Having identified ISE \ISE{3} detailed in
\REFSEC{sec:design:v3} as a strong candidate for embedded $32$-bit
RISC-V cores, we now show a possible
way of extending the ISE further to add power side-channel resistance
with minimal area and performance overheads.
We aim for $1$'st order side-channel security.

As described in \cite{TilGro:07}, there are several broad approaches
to adding power side-channel security to ISEs which we summarise here:

1) The data path can be implemented in a secure logic style, which always
consumes energy at the same rate, regardless of the values being computed on.
This comes with a significant overhead in terms of silicon area and
gate-level performance.
It also requires that secret values only be stored in secure logic
elements.
This can be undermined when loading keys from memory, since they must
pass through any register stages in the memory hierarchy, which are
unlikely to be implemented in a secure logic style.

2) Random pre-charging involves sandwiching every instruction which
manipulates a secret value with instructions which operate on random values.
As the authors of \cite{TilGro:07} note, it provides only a modest
improvement in security, and comes with a $100\%$ performance overhead;
since every secret manipulating instruction must be accompanied by
a random-pre-charging partner.

3) The authors also describe a small ``secure zone'' within the processor,
implemented in a secure logic style and responsible for
mask storage, generation and all computations on secret data.
The aim is to keep the secure zone as small and separate from the main
processor data-path as possible.

\subsection{Design Overview}

We extend ISE \ISE{3} to support 1'st order masking.
To this end, the secret key is represented as two boolean masked shares.
An implementation of the AES block encrypt/decrypt function requires
eight registers: four for the current round state, four to load the
next round key into and then accumulate the next round state.
Doubling this requirement to store shares of each secret variable
in the General Purpose Register (GPR) file is un-reasonable.
It would require drastic modifications to the instruction definitions and
register file to read four registers (two sources, of two shares each) and
write two registers.

Instead, we define a new, $8$-element ``Mask Register File'' (MRF).
Each mask register $M_i$ is $32$-bits wide, and stores the mask for
one of the GPRs.
We use a fixed mapping between GPRs and mask registers;
not all GPRs have a corresponding mask register.
({\bf TODO:} define this mapping. E.g. \{a0..a3,t0..t4\} onto MRF \{0..7\}).

Share $0$ of each secret value is loaded into the GPRs.
We define a new Load Mask instruction {\tt lm rd, imm(rs1)} which
loads {\em the mask for GPR {\tt rd}} from memory into the corresponding
MRF entry.
A corresponding Store Mask instruction {\tt sm rs2, imm(rs1)} writes
the mask corresponding to GPR {\tt rs2} to memory.
The {\tt sm} instruction is only used for context switches, and
destructively reads the MRF register value to prevent it being
leaked to other applications running on the same core\footnote{
    In this case, destructive could mean set to zero (which could
    leak the hamming weight of the mask) or randomising it's value.}.
We require that the secret values be stored in shared form in memory
(rather than splitting them into shares upon being loaded)
to extend the SCA protection boundary outside the CPU.
Otherwise, the hamming weight of un-masked secret values would be
leaked by memory-hierarchy registers outside the CPU.

When an ISE instruction is executed such that any of its GPR source
registers also map onto an MRF register, both GPR and MRF are
read simultaneously and fed to the AES functional unit.
If any GPR source does not map to an MRF register, we assume that
operand is un-masked and represent the other share as $0$.

Within the AES FU the instruction result is computed entirely in it's
masked representation.
The result shares are then re-masked before being written back to the
GPRs and MRF.
This is necessary, because \ISE{3} instructions are designed
such that {\tt rs1=rd} for all use cases.
Without re-masking, overwriting a source with the result could cause 
$1$'st order leakage.

If the destination register is in the set which has a corresponding
mask register, share $0$ is stored in the GPRs, share $1$ in the MRF.
If destination is not a GPR, result is written back un-masked.
This means that in the final encrypt/decrypt round, we can obtain
the un-masked results without having to store the shares to memory,
load them back and un-mask them.

\subsection{Implementation}

We use the \CORE{2} core as the basis for our side-channel secure
implementation of \ISE{3}.
\REFFIG{fig:sca:uarch} shows a block diagram of the modifications
made to the core, and which data-paths carry masked data.

\begin{figure}
\caption{Block diagram of the modifications to the \CORE{2} core,
supporting an extended version of ISE \ISE{3} for side-channel
security. {\bf TODO}}
\label{fig:sca:uarch}
\end{figure}


\subsection{Evaluation}

We used a standard experiment plaform to evaluate the power side-channel
hardened AES \ISE{3} instructions, the details of which are found
below.

The modified version of the \CORE{2} core was implemented on a
Sasebo GIII \cite{HKSS:12}
side-channel analysis platform, containing two FPGAs:
a Xilinx  Kintex-7 
(model {\tt xc7k160tfbg676})
target  FPGA 
and
a Xilinx Spartan-6
(model {\tt xc6slx45})
support FPGA.
Only the Kintex-7 was used.
The design was synthesised using Xilinx Vivado 2019.2 with
default synthesis and implementaiton strategies.
No effort was spent on optimising the synthesis or routing.
The Kintex-7 FPGA uses a 200MHz differential external clock source, which is
transformed into a 50MHz internal clock used by the entire
design.

Trace capture uses a standard pipeline of components, including:
a MiniCircuits BLK+89 D/C blocker,
an Agilent 8447D amplifier (with a $\SI{100}{\kilo\hertz}$ to $\SI{1.3}{\giga\hertz}$ range, and $\SI{25}{\decibel}$ gain),
and
a  PicoScope 5000 series oscilloscope.
The oscilloscope uses a 250 MHz sample rate, with a 12-bit sample resolution.
The capture process is coordinated using a laptop, which is responsible for:
1) configuring the target device with the correct experiment program,
2) uploading and retrieving experiment input and output values,
3) recording oscilloscope trace data and packaging it for storage.

We performed a generic Test Vector Leakage Assessment (TVLA) flow to evaluate
the effectivness of the side-channel hardened implementation;
using the AES-128 block encrypt function as the target operation.
The un-protected and protected implementation results are shown in
\REFFIG{fig:sca:unprotected} and
\REFFIG{fig:sca:protected} respectivley.
Clearly, the protected implementaiton is effective at removing $1$'st
order side-channel leakage.

\REFTAB{tab:sca:sw-hw} show the impact on hardware and software cost
of the side-channel hardening.

\begin{table}[]
\centering
\begin{tabular}{lrr}
Metric                & Un-protected AES-128 & Protected AES-128 \\
\hline
Static Code Size      & 290                  & TODO              \\
Instructions Executed & 261                  & TODO              \\
CPU Clock Cycles      & 351                  & TODO              \\
ISE Size (NAND2)      & 1157                 & 4616              \\
ISE LTP               & 30                   & 37                \\
CPU Size (NAND2)      & 38610                & 45141             \\
CPU Size  LUTs        & 4017                 & 4956              \\
CPU Size  FFs         & 2078                 & 2420              \\
Timing Slack @50MHz   & 8.12ns               & 7.05ns
\end{tabular}
\caption{
Software and hardware overheads for the protected ISE implementation.
The ``ISE Size'' row does not include the cost of the mask register file
for the protected implementation.
This is included in the CPU size measurements, since the exact method
of mask delivery and storage is an implmentation option.
}
\label{tab:sca:sw-hw}
\end{table}

\begin{figure}
\centering
\begin{subfigure}[t]{0.95\textwidth}
\centering
\includegraphics[width=\textwidth]{graphs/aes-vanilla-enc-default-ttest.png}
\caption{
    Un-protected implementation TVLA results after $10$K traces.
}
\label{fig:sca:unprotected}
\end{subfigure}
\begin{subfigure}[t]{0.95\textwidth}
\centering
\includegraphics[width=\textwidth]{graphs/aes-secure-enc-default-ttest.png}
\caption{
    Side-channel protected implementation TVLA results after $100$K traces.
}
\label{fig:sca:protected}
\end{subfigure}
\caption{
TVLA results for the baseline and protected implementations.
The blue trace is the absoloute result of the TVLA evaluation, the green
trace is the average power consumption for each TVLA trace set.
}
\end{figure}
